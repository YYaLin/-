# é¡¹ç›®å‘¨æŠ¥

**æ—¥æœŸ**ï¼š2025-5-11
**é¡¹ç›®å®è·µé¢˜ç›®**ï¼šé¢å‘æœºå™¨å­¦ä¹ çš„æ•°æ®æ¸…æ´—æ–¹æ³•

## å®è·µå†…å®¹
### æ”¯çº¿
```python
from openai import OpenAI

client = OpenAI(api_key="è‡ªå·±çš„key", 
                base_url="https://api.siliconflow.cn/v1")
response = client.chat.completions.create(
    model="æ¨¡å‹åç§°",
    messages=[
        {'role': 'user', 
        'content': "å†…å®¹"}
    ],
    stream=True
)

for chunk in response:
    if not chunk.choices:
        continue
    if chunk.choices[0].delta.content:
        print(chunk.choices[0].delta.content, end="", flush=True)
    if chunk.choices[0].delta.reasoning_content:
        print(chunk.choices[0].delta.reasoning_content, end="", flush=True)
```
**å›ç­”ï¼š** Hello! It seems like your message is a friendly comment. How can I assist you today? If you have any questions or need help with something, feel free to ask!ğŸ˜Š

### è®ºæ–‡ç®€å•ä»£ç ç¼–å†™
**ä½¿ç”¨ResNet18è®­ç»ƒCIFAR-10**
```python
# Vanilla
class VanillaTrainer:
    def __init__(self, config=None):
        self.model = ResNet18().cuda()
        self.criterion = nn.CrossEntropyLoss()
        self.optimizer = optim.Adam(self.model.parameters(), lr=1e-3)

    def train(self, dataloader):
        self.model.train()
        for images, labels in tqdm(dataloader, desc="Vanilla Training"):
            images, labels = images.cuda(), labels.cuda()
            outputs = self.model(images)
            loss = self.criterion(outputs, labels)
            self.optimizer.zero_grad()
            loss.backward()
            self.optimizer.step()

    def predict(self, dataloader):
        self.model.eval()
        preds = []
        with torch.no_grad():
            for images, _ in tqdm(dataloader, desc="Vanilla Predict"):
                images = images.cuda()
                outputs = self.model(images)
                preds.extend(outputs.argmax(dim=1).cpu().numpy())
        return np.array(preds)
```

```python
# CoTeaching
class CoTeachingTrainer:
    def __init__(self, config=None):
        self.model1 = ResNet18().cuda()
        self.model2 = ResNet18().cuda()
        self.criterion = nn.CrossEntropyLoss(reduction='none')
        self.optimizer1 = optim.Adam(self.model1.parameters(), lr=1e-3)
        self.optimizer2 = optim.Adam(self.model2.parameters(), lr=1e-3)

    def train(self, dataloader, epochs=5, keep_ratio=0.8):
        for epoch in range(epochs):
            self.model1.train()
            self.model2.train()
            print(f"Epoch {epoch+1}/{epochs}")
            for images, labels in tqdm(dataloader, desc="CoTeaching Training"):
                images, labels = images.cuda(), labels.cuda()
                logits1 = self.model1(images)
                logits2 = self.model2(images)

                loss1 = self.criterion(logits1, labels)
                loss2 = self.criterion(logits2, labels)

                # é€‰æ‹©æŸå¤±è¾ƒå°çš„æ ·æœ¬ï¼ˆæ›´æœ‰å¯èƒ½æ˜¯å¹²å‡€çš„ï¼‰
                idx1 = torch.argsort(loss1)[:int(len(loss1) * keep_ratio)]
                idx2 = torch.argsort(loss2)[:int(len(loss2) * keep_ratio)]

                # æ¨¡å‹1ç”¨æ¨¡å‹2é€‰çš„æ ·æœ¬è®­ç»ƒï¼Œåä¹‹äº¦ç„¶
                self.optimizer1.zero_grad()
                loss = self.criterion(self.model1(images[idx2]), labels[idx2]).mean()
                loss.backward()
                self.optimizer1.step()

                self.optimizer2.zero_grad()
                loss = self.criterion(self.model2(images[idx1]), labels[idx1]).mean()
                loss.backward()
                self.optimizer2.step()

    def predict(self, dataloader):
        self.model1.eval()
        self.model2.eval()
        preds = []
        with torch.no_grad():
            for images, _ in tqdm(dataloader, desc="CoTeaching Predict"):
                images = images.cuda()
                out1 = self.model1(images)
                out2 = self.model2(images)
                avg_out = (out1 + out2) / 2
                preds.extend(avg_out.argmax(dim=1).cpu().numpy())
        return np.array(preds)
```

```python
class ELRTrainer:
    def __init__(self, config=None):
        self.model = ResNet18().cuda()
        self.criterion = nn.CrossEntropyLoss()
        self.optimizer = optim.Adam(self.model.parameters(), lr=1e-3)

    def train(self, dataloader, epochs=10):
        self.model.train()
        for epoch in range(epochs):
            print(f"Epoch {epoch+1}/{epochs}")
            for images, labels in tqdm(dataloader, desc="ELR Training"):
                images, labels = images.cuda(), labels.cuda()
                outputs = self.model(images)
                loss = self.criterion(outputs, labels)
                self.optimizer.zero_grad()
                loss.backward()
                self.optimizer.step()

    def predict(self, dataloader):
        self.model.eval()
        preds = []
        with torch.no_grad():
            for images, _ in tqdm(dataloader, desc="ELR Predict"):
                images = images.cuda()
                outputs = self.model(images)
                preds.extend(outputs.argmax(dim=1).cpu().numpy())
        return np.array(preds)
```
### è®­ç»ƒç»“æœ
æ ‡ç­¾å‡†ç¡®ç‡:
Vanilla: 0.7267
CoTeaching: 0.7999
ELR: 0.7938
**åç»­ä¼šç»§ç»­å®Œå–„è¡¥å……**
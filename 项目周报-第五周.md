# 项目周报

**日期**：2025-5-11
**项目实践题目**：面向机器学习的数据清洗方法

## 实践内容
### 支线
```python
from openai import OpenAI

client = OpenAI(api_key="自己的key", 
                base_url="https://api.siliconflow.cn/v1")
response = client.chat.completions.create(
    model="模型名称",
    messages=[
        {'role': 'user', 
        'content': "内容"}
    ],
    stream=True
)

for chunk in response:
    if not chunk.choices:
        continue
    if chunk.choices[0].delta.content:
        print(chunk.choices[0].delta.content, end="", flush=True)
    if chunk.choices[0].delta.reasoning_content:
        print(chunk.choices[0].delta.reasoning_content, end="", flush=True)
```
**回答：** Hello! It seems like your message is a friendly comment. How can I assist you today? If you have any questions or need help with something, feel free to ask!😊

### 论文简单代码编写
**使用ResNet18训练CIFAR-10**
```python
# Vanilla
class VanillaTrainer:
    def __init__(self, config=None):
        self.model = ResNet18().cuda()
        self.criterion = nn.CrossEntropyLoss()
        self.optimizer = optim.Adam(self.model.parameters(), lr=1e-3)

    def train(self, dataloader):
        self.model.train()
        for images, labels in tqdm(dataloader, desc="Vanilla Training"):
            images, labels = images.cuda(), labels.cuda()
            outputs = self.model(images)
            loss = self.criterion(outputs, labels)
            self.optimizer.zero_grad()
            loss.backward()
            self.optimizer.step()

    def predict(self, dataloader):
        self.model.eval()
        preds = []
        with torch.no_grad():
            for images, _ in tqdm(dataloader, desc="Vanilla Predict"):
                images = images.cuda()
                outputs = self.model(images)
                preds.extend(outputs.argmax(dim=1).cpu().numpy())
        return np.array(preds)
```

```python
# CoTeaching
class CoTeachingTrainer:
    def __init__(self, config=None):
        self.model1 = ResNet18().cuda()
        self.model2 = ResNet18().cuda()
        self.criterion = nn.CrossEntropyLoss(reduction='none')
        self.optimizer1 = optim.Adam(self.model1.parameters(), lr=1e-3)
        self.optimizer2 = optim.Adam(self.model2.parameters(), lr=1e-3)

    def train(self, dataloader, epochs=5, keep_ratio=0.8):
        for epoch in range(epochs):
            self.model1.train()
            self.model2.train()
            print(f"Epoch {epoch+1}/{epochs}")
            for images, labels in tqdm(dataloader, desc="CoTeaching Training"):
                images, labels = images.cuda(), labels.cuda()
                logits1 = self.model1(images)
                logits2 = self.model2(images)

                loss1 = self.criterion(logits1, labels)
                loss2 = self.criterion(logits2, labels)

                # 选择损失较小的样本（更有可能是干净的）
                idx1 = torch.argsort(loss1)[:int(len(loss1) * keep_ratio)]
                idx2 = torch.argsort(loss2)[:int(len(loss2) * keep_ratio)]

                # 模型1用模型2选的样本训练，反之亦然
                self.optimizer1.zero_grad()
                loss = self.criterion(self.model1(images[idx2]), labels[idx2]).mean()
                loss.backward()
                self.optimizer1.step()

                self.optimizer2.zero_grad()
                loss = self.criterion(self.model2(images[idx1]), labels[idx1]).mean()
                loss.backward()
                self.optimizer2.step()

    def predict(self, dataloader):
        self.model1.eval()
        self.model2.eval()
        preds = []
        with torch.no_grad():
            for images, _ in tqdm(dataloader, desc="CoTeaching Predict"):
                images = images.cuda()
                out1 = self.model1(images)
                out2 = self.model2(images)
                avg_out = (out1 + out2) / 2
                preds.extend(avg_out.argmax(dim=1).cpu().numpy())
        return np.array(preds)
```

```python
class ELRTrainer:
    def __init__(self, config=None):
        self.model = ResNet18().cuda()
        self.criterion = nn.CrossEntropyLoss()
        self.optimizer = optim.Adam(self.model.parameters(), lr=1e-3)

    def train(self, dataloader, epochs=10):
        self.model.train()
        for epoch in range(epochs):
            print(f"Epoch {epoch+1}/{epochs}")
            for images, labels in tqdm(dataloader, desc="ELR Training"):
                images, labels = images.cuda(), labels.cuda()
                outputs = self.model(images)
                loss = self.criterion(outputs, labels)
                self.optimizer.zero_grad()
                loss.backward()
                self.optimizer.step()

    def predict(self, dataloader):
        self.model.eval()
        preds = []
        with torch.no_grad():
            for images, _ in tqdm(dataloader, desc="ELR Predict"):
                images = images.cuda()
                outputs = self.model(images)
                preds.extend(outputs.argmax(dim=1).cpu().numpy())
        return np.array(preds)
```
### 训练结果
标签准确率:
Vanilla: 0.7267
CoTeaching: 0.7999
ELR: 0.7938
**后续会继续完善补充**